# Ограничение времени	5 секунд
# Ограничение памяти	256Mb
#
# Домашний питомец мальчика Васи — улитка Петя. Петя обитает на бесконечном в обе стороны вертикальном столбе,
# который для удобства можно представить как числовую прямую. Изначально Петя находится в точке 0.
#
# Вася кормит Петю ягодами. У него есть n ягод, каждая в единственном экземпляре. Вася знает, что если утром он даст
# Пете ягоду с номером i, то поев и набравшись сил, за остаток дня Петя поднимется на a(i) единиц вверх по столбу,
# но при этом за ночь, потяжелев, съедет на b(i) единиц вниз. Параметры различных ягод могут совпадать.
#
# Пете стало интересно, а как оно там, наверху, и Вася взялся ему в этом помочь. Ближайшие n дней он будет
# кормить Петю ягодами из своего запаса таким образом, чтобы максимальная высота, на которой побывал Петя
# за эти n дней была максимальной. К сожалению, Вася не умеет программировать, поэтому он попросил вас о помощи.
# Найдите, максимальную высоту, на которой Петя сможет побывать за эти n дней и в каком порядке Вася должен давать
# Пете ягоды, чтобы Петя смог её достичь!
#
# Формат ввода
# В первой строке входных данных дано число n(1 ≤ n ≤ 5*10**5) — количество ягод у Васи.
# В последующих n строках описываются параметры каждой ягоды.
# В i+1 строке дано два числа a(i) и b(i) (0 ≤ a(i), b(i) ≤ 10**9) — то, насколько поднимется улитка за день
# после того, как съест i ягоду и насколько опуститься за ночь.
#
# Формат вывода
# В первой строке выходных данных выведите единственное число — максимальную высоту, которую сможет достичь Петя,
# если Вася будет его кормить оптимальным образом.
# В следующей строке выведите n различных целых чисел от 1 до n — порядок, в котором Вася должен кормить Петю
# (i число в строке соответствует номеру ягоды, которую Вася должен дать Пете в i день,
# чтобы Петя смог достичь максимальной высоты).
#
# Пример 1
# Ввод
# 3
# 1 5
# 8 2
# 4 4
#
# Вывод
# 10
# 2 3 1
#
# Пример 2
# Ввод
# 2
# 7 6
# 7 4
#
# Вывод
# 10
# 2 1
#
# Примечания
# Во втором примере изначально улитка находится на высоте 0. Пусть сначала Петя накормит её второй ягодой,
# а затем первой. После того как она съест вторую ягоду, за день она поднимется на 7 (и окажется на высоте 7),
# а за ночь опустится на 4 (и окажется на высоте 3). После того как она съест первую ягоду, за день она поднимется на 7
# (и окажется на высоте 10), а за ночь опустится на 6 (и окажется на высоте 4).
#
# Таким образом, максимальная высота, на которой побывает улитка при данном порядке кормления, равна 10.
# Нетрудно видеть, что если Петя накормит улитку сначала первой ягодой, а затем второй, то максимальная высота,
# на которой побывает улитка, будет меньше.

def get_steps_generator(file_):
    for line in file_:
        yield map(int, line.split())


def find_max_up_neg_step(steps_lst, hash_map_dct):
    max_up = 0
    step = 0
    for i_step in steps_lst:
        if hash_map_dct[i_step][0] > max_up:
            max_up = hash_map_dct[i_step][0]
            step = i_step

    steps_lst.remove(step)
    steps_lst.insert(0, step)
    return steps_lst


def find_lastberry(steps_lst, hash_map_dct):
    max_up = 0
    min_diff = float("inf")
    step = None
    for i_step in steps_lst:
        if hash_map_dct[i_step][2] < min_diff:
            if hash_map_dct[i_step][1] > max_up:
                max_up = hash_map_dct[i_step][1]
                step = i_step
    if step:
        steps_lst.remove(step)
        steps_lst.append(step)

    return steps_lst


with open('input.txt', 'r', encoding='utf-8') as file:
    cnt = int(file.readline())
    hash_map = {}

    pos_steps = []
    neg_steps = []

    # Заполняем списки
    i = 1
    for up, down in get_steps_generator(file):
        diff = up - down
        if diff >= 0:
            pos_steps.append(i)
        else:
            neg_steps.append(i)
        hash_map[i] = (up, down, diff)
        i += 1
    if len(neg_steps) > 1:
        neg_steps = find_max_up_neg_step(neg_steps, hash_map)
    pos_steps = find_lastberry(pos_steps, hash_map)

    steps = pos_steps + neg_steps

    max_height = 0
    neg_cnt = 0
    height = 0
    for key in steps:
        diff = hash_map[key][0] - hash_map[key][1]
        if hash_map[key][2] < 0:
            neg_cnt += 1
        height += hash_map[key][0]
        max_height = max(max_height, height)
        height -= hash_map[key][1]
        if neg_cnt > 1:
            break

    print(max_height)
    print(*steps)

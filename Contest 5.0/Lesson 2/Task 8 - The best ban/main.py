# Ограничение времени	3 секунды
# Ограничение памяти	256Mb
#
# Константин и Михаил играют в настольную игру «Ярость Эльфов». В игре есть n рас и m классов персонажей. Каждый
# персонаж характеризуется своими расой и классом. Для каждой расы и каждого класса существует ровно один п
# ерсонаж такой расы и такого класса. Сила персонажа i-й расы и j-го класса равна ai j, и обоим игрокам
# это прекрасно известно.
#
# Сейчас Константин будет выбирать себе персонажа. Перед этим Михаил может запретить одну расу и один класс, чтобы
# Константин не мог выбирать персонажей, у которых такая раса или такой класс. Конечно же, Михаил старается, чтобы
# Константину достался как можно более слабый персонаж, а Константин, напротив, выбирает персонажа посильнее.
# Какие расу и класс следует запретить Михаилу?
#
# Формат ввода
# Первая строка содержит два целых числа n и m (2 ≤ n, m ≤ 1000) через пробел — количество рас и классов в игре
# «Ярость Эльфов», соответственно.
#
# В следующих n строках содержится по m целых чисел через пробел. j-е число i-й из этих строк — это a(i) j
# (1 ≤ ai j ≤ 109).
#
# Формат вывода
# В единственной строке выведите два целых числа через пробел — номер расы и номер класса, которые следует запретить
# Михаилу. Расы и классы нумеруются с единицы. Если есть несколько возможных ответов, выведите любой из них.
#
# Пример 1
# Ввод
# 2 2
# 1 2
# 3 4
#
# Вывод
# 2 2
#
# Пример 2
# Ввод
# 3 4
# 1 3 5 7
# 9 11 2 4
# 6 8 10 12
#
# Вывод
# 3 2

def find_max(w, bannedrow, bannedcol):
    answer = 0
    r = c = 0
    for i in range(len(w)):
        if i != bannedrow:
            for j in range(len(w[0])):
                if j != bannedcol and w[i][j] > answer:
                    answer = w[i][j]
                    r = i
                    c = j
    return r, c, answer


def find_strongest_race_and_class(matrix):
    # находим абсолютный максимум
    fr, fc, maxval = find_max(matrix, -1, -1)

    # блокируем строку
    # находим колонку со вторым от максимума значением с заблокированной строкой
    banr, banc, tempvalr = find_max(matrix, fr, -1)
    # находим 3-е число от максимума, чтобы узнать, лучшее ли сочетание строки и колонки нашли или нет
    tempr, tempc, banrval = find_max(matrix, fr, banc)

    # блокируем колонку
    # находим строку с максимальным 2-м значением с заблокированной колонкой
    bancr, bancc, tempvalc = find_max(matrix, -1, fc)
    # находим 3-е число от максимума, чтобы узнать, лучшее ли сочетание колонки и строки нашли или нет
    tempr, tempc, bancval = find_max(matrix, bancr, fc)

    # проверяем, в каком из вариантов самое маленькое третье число
    # - это и есть наши лучшие сочетания строки и колонки
    if banrval < bancval:
        return [fr + 1, banc + 1]
    else:
        return [bancr + 1, fc + 1]


with open('input.txt', 'r', encoding='utf-8') as file:
    matrix_size = list(map(int, file.readline().split()))
    matrix = []
    for _ in range(matrix_size[0]):
        matrix.append(list(map(int, file.readline().split())))
    result = find_strongest_race_and_class(matrix)
    print(*result)

# tests = [
#     (2, 2, [[1, 2], [3, 4]], [2, 2]),
#     (3, 4, [[1, 3, 5, 7], [9, 11, 2, 4], [6, 8, 10, 12]], [3, 2])
# ]
#
# for n, m, impact_forces, ans in tests:
#     assert find_strongest_race_and_class(impact_forces) == ans, f'Test {n} {m} {impact_forces}'
